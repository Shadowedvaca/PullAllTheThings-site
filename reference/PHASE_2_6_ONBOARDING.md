# Phase 2.6: New Member Onboarding & Auto-Provisioning

## Overview

This phase creates an end-to-end automated onboarding pipeline. When someone joins the
Discord server, the bot guides them through identification, verifies them against the
guild roster, and â€” once confirmed â€” automatically provisions them across all PATT systems:
website account, roster entries, and Discord roles.

**The full lifecycle:**
```
Discord Join â†’ Bot DM Conversation â†’ Pending Identity Link
    â†’ Blizzard API Verification (next sync or on-demand)
        â†’ CONFIRMED: Auto-provision website invite + roster entries + Discord role
        â†’ NOT CONFIRMED in 24h: Flag #audit-channel for officer review
```

**This phase produces:**
1. A Discord DM onboarding conversation flow
2. Pending onboarding tracking (DB table + scheduler jobs)
3. Auto-verification against Blizzard API roster data
4. Website invite code generation and delivery
5. Auto-roster setup (all characters listed, sensible defaults)
6. First-login experience (see your chars, map additional ones)
7. 24-hour escalation to #audit-channel for unverified members

## Prerequisites
- Phase 2.5 complete (identity system, Blizzard sync, Discord sync all running)
- Phase 2 website auth system functional (invite codes, login)
- Roster management system operational

## Architecture Context

This phase touches multiple existing systems:

| System | What 2.6 Adds |
|---|---|
| Discord Bot | DM onboarding flow, conversation state machine |
| Identity Engine | New link source `"self_reported"`, pending link concept |
| Integrity Checker | New issue type `"unverified_new_member"` |
| Website Auth | Programmatic invite code generation |
| Roster System | Auto-creation of character entries with defaults |
| Scheduler | 24-hour verification deadline jobs |

## Database Schema Additions

```sql
-- Add to guild_identity schema

-- Tracks the onboarding state for new Discord members
CREATE TABLE guild_identity.onboarding_sessions (
    id SERIAL PRIMARY KEY,
    discord_member_id INTEGER NOT NULL REFERENCES guild_identity.discord_members(id) ON DELETE CASCADE,
    discord_id VARCHAR(25) NOT NULL,  -- Denormalized for quick lookup
    
    -- Conversation state
    state VARCHAR(30) NOT NULL DEFAULT 'awaiting_dm',
    -- States: awaiting_dm, asked_in_guild, asked_main, asked_alts,
    --         pending_verification, verified, provisioned,
    --         timed_out, manually_resolved, declined
    
    -- Self-reported data from DM conversation
    reported_main_name VARCHAR(50),
    reported_main_realm VARCHAR(100),
    reported_alt_names TEXT[],          -- Array of "Name-Realm" strings
    is_in_guild BOOLEAN,               -- Their answer to "are you in the guild?"
    
    -- Verification tracking
    verification_attempts INTEGER DEFAULT 0,
    last_verification_at TIMESTAMPTZ,
    verified_at TIMESTAMPTZ,
    verified_person_id INTEGER REFERENCES guild_identity.persons(id),
    
    -- Provisioning tracking
    website_invite_sent BOOLEAN DEFAULT FALSE,
    website_invite_code VARCHAR(50),
    roster_entries_created BOOLEAN DEFAULT FALSE,
    discord_role_assigned BOOLEAN DEFAULT FALSE,
    
    -- Lifecycle
    dm_sent_at TIMESTAMPTZ,
    dm_completed_at TIMESTAMPTZ,
    deadline_at TIMESTAMPTZ,            -- 24 hours after DM completion
    escalated_at TIMESTAMPTZ,           -- When flagged to #audit-channel
    completed_at TIMESTAMPTZ,           -- When fully provisioned or manually resolved
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    UNIQUE(discord_id)  -- One active session per Discord user
);

CREATE INDEX idx_onboarding_state ON guild_identity.onboarding_sessions(state);
CREATE INDEX idx_onboarding_deadline ON guild_identity.onboarding_sessions(deadline_at)
    WHERE state = 'pending_verification';

-- Track website invite codes generated by the system
-- (extends whatever invite table exists from Phase 2)
-- Add a column or create if needed:
ALTER TABLE website_auth.invite_codes 
    ADD COLUMN IF NOT EXISTS generated_by VARCHAR(30) DEFAULT 'manual',
    -- 'manual' = officer created, 'auto_onboarding' = system generated
    ADD COLUMN IF NOT EXISTS onboarding_session_id INTEGER 
        REFERENCES guild_identity.onboarding_sessions(id);
```

## Task 1: DM Onboarding Conversation Flow

The bot manages a multi-step DM conversation using discord.py's `wait_for` pattern
with a state machine for resilience (handles disconnects, slow responders, etc.).

```python
# sv_common/guild_sync/onboarding/conversation.py

"""
Discord DM onboarding conversation for new guild members.

Flow:
1. Welcome message + "Have you joined the guild in WoW?"
2a. YES â†’ "What's your main character's name?" â†’ "What realm?" â†’ "Any alts?"
2b. NO  â†’ "No worries! When you do, type /pattsync here or just reply to me"
           â†’ Set a 24h check-in timer
3. Store self-reported data â†’ attempt immediate verification
4. If verified â†’ auto-provision â†’ welcome them in guild chat
5. If not verified â†’ schedule 24h deadline â†’ escalate if unresolved

Design principles:
- Friendly, casual tone matching PATT culture
- Forgiving of typos (fuzzy matching on character names)
- Non-blocking: if they stop responding, state is saved and we follow up
- Officers can /onboard-status to see pending onboardings
"""

import asyncio
import logging
from datetime import datetime, timezone, timedelta
from typing import Optional

import asyncpg
import discord

logger = logging.getLogger(__name__)

# Timeouts for DM responses
RESPONSE_TIMEOUT = 300  # 5 minutes per question before we save state and check back later
FOLLOWUP_DELAY = 3600   # 1 hour before we nudge them if they went silent
DEADLINE_HOURS = 24      # Hours before escalation to #audit-channel

# PATT Gold color for embeds
PATT_GOLD = 0xD4A84B


class OnboardingConversation:
    """Manages a single new member's onboarding DM conversation."""
    
    def __init__(
        self,
        bot: discord.Client,
        member: discord.Member,
        db_pool: asyncpg.Pool,
    ):
        self.bot = bot
        self.member = member
        self.db_pool = db_pool
        self.session_id: Optional[int] = None
    
    async def start(self):
        """
        Begin the onboarding conversation.
        
        Called from the on_member_join event handler.
        Creates a DB session and sends the first DM.
        """
        # Create onboarding session
        async with self.db_pool.acquire() as conn:
            # Check if there's already an active session
            existing = await conn.fetchrow(
                """SELECT id, state FROM guild_identity.onboarding_sessions
                   WHERE discord_id = $1 AND state NOT IN ('provisioned', 'manually_resolved', 'declined')""",
                str(self.member.id)
            )
            
            if existing:
                logger.info("Onboarding session already exists for %s (state: %s)", 
                           self.member.name, existing['state'])
                self.session_id = existing['id']
                return
            
            # Get or create discord_member row
            dm_row = await conn.fetchrow(
                "SELECT id FROM guild_identity.discord_members WHERE discord_id = $1",
                str(self.member.id)
            )
            
            if not dm_row:
                # This should have been created by on_member_join in Phase 2.5
                # but just in case, handle gracefully
                logger.warning("No discord_member row for %s, creating one", self.member.name)
                dm_id = await conn.fetchval(
                    """INSERT INTO guild_identity.discord_members
                       (discord_id, username, display_name, is_present, joined_server_at)
                       VALUES ($1, $2, $3, TRUE, $4)
                       ON CONFLICT (discord_id) DO UPDATE SET is_present = TRUE
                       RETURNING id""",
                    str(self.member.id), self.member.name,
                    self.member.nick or self.member.display_name,
                    self.member.joined_at,
                )
            else:
                dm_id = dm_row['id']
            
            self.session_id = await conn.fetchval(
                """INSERT INTO guild_identity.onboarding_sessions
                   (discord_member_id, discord_id, state)
                   VALUES ($1, $2, 'awaiting_dm')
                   ON CONFLICT (discord_id) DO UPDATE SET state = 'awaiting_dm', updated_at = NOW()
                   RETURNING id""",
                dm_id, str(self.member.id)
            )
        
        # Send the first DM
        try:
            await self._send_welcome()
        except discord.Forbidden:
            logger.warning("Cannot DM %s â€” DMs are closed", self.member.name)
            await self._update_state('declined', notes="DMs closed")
            # We could post in a welcome channel instead as fallback
    
    async def _send_welcome(self):
        """Send the welcome DM and ask if they're in the guild."""
        embed = discord.Embed(
            title="Welcome to Pull All The Things! ðŸŽ®",
            description=(
                "Hey there! Welcome to the PATT Discord! I'm the guild bot and I'm here "
                "to get you set up.\n\n"
                "**Have you already joined the guild in World of Warcraft?**\n\n"
                "Just reply with **yes** or **no** â€” no rush!"
            ),
            color=PATT_GOLD,
        )
        embed.set_footer(text="Pull All The Things â€¢ Sen'jin")
        
        dm_channel = await self.member.create_dm()
        await dm_channel.send(embed=embed)
        
        await self._update_state('asked_in_guild')
        
        # Wait for response
        response = await self._wait_for_response(dm_channel)
        
        if response is None:
            # They didn't respond â€” save state, scheduler will follow up
            return
        
        answer = response.content.strip().lower()
        
        if answer in ('yes', 'y', 'yeah', 'yep', 'yea', 'si', 'ye', 'yup'):
            await self._update_field('is_in_guild', True)
            await self._ask_main_character(dm_channel)
        elif answer in ('no', 'n', 'nah', 'nope', 'not yet'):
            await self._update_field('is_in_guild', False)
            await self._handle_not_in_guild(dm_channel)
        else:
            # Unclear answer â€” assume yes and continue
            await dm_channel.send(
                "I'll take that as a yes! ðŸ˜„ Let's get you set up."
            )
            await self._update_field('is_in_guild', True)
            await self._ask_main_character(dm_channel)
    
    async def _ask_main_character(self, dm_channel: discord.DMChannel):
        """Ask for their main character name."""
        await dm_channel.send(
            "Awesome! **What's your main character's name?**\n"
            "Just the character name is fine â€” I'll try to find them in the guild roster."
        )
        
        await self._update_state('asked_main')
        
        response = await self._wait_for_response(dm_channel)
        if response is None:
            return
        
        main_name = response.content.strip()
        
        # Try to clean up common input issues
        # People might type "Trogmoon - Sen'jin" or "Trogmoon (Druid)"
        # Just take the first word-ish chunk
        main_name = main_name.split('-')[0].split('(')[0].split('/')[0].strip()
        
        await self._update_field('reported_main_name', main_name)
        
        # Try to find them in the guild roster immediately
        match = await self._try_find_character(main_name)
        
        if match:
            realm = match.get('realm_name', match.get('realm_slug', 'unknown'))
            await dm_channel.send(
                f"Found **{match['character_name']}** on **{realm}** â€” "
                f"{match['character_class']}, {match.get('guild_rank_name', 'guild member')}! "
                f"That you? ðŸŽ‰\n\n"
                f"**Do you have any alts in the guild?** "
                f"List them separated by commas, or say **none**."
            )
            await self._update_field('reported_main_realm', match['realm_slug'])
        else:
            await dm_channel.send(
                f"I don't see **{main_name}** in the roster yet â€” that's okay! "
                f"The roster syncs a few times a day, so if you just joined, "
                f"I'll catch it soon.\n\n"
                f"**Do you have any alts in the guild?** "
                f"List them separated by commas, or say **none**."
            )
        
        await self._ask_alts(dm_channel)
    
    async def _ask_alts(self, dm_channel: discord.DMChannel):
        """Ask for alt characters."""
        await self._update_state('asked_alts')
        
        response = await self._wait_for_response(dm_channel)
        if response is None:
            return
        
        answer = response.content.strip()
        
        if answer.lower() in ('none', 'no', 'nope', 'n/a', 'na', '0', '-'):
            alt_names = []
        else:
            # Parse comma-separated alt names
            alt_names = [
                name.strip().split('-')[0].split('(')[0].strip()
                for name in answer.split(',')
                if name.strip()
            ]
        
        await self._update_field('reported_alt_names', alt_names)
        
        # Wrap up the DM
        char_list = f"**Main:** {await self._get_field('reported_main_name')}"
        if alt_names:
            char_list += f"\n**Alts:** {', '.join(alt_names)}"
        
        embed = discord.Embed(
            title="Got it! You're all set on my end ðŸ‘",
            description=(
                f"{char_list}\n\n"
                "I'm going to verify this against the guild roster. "
                "Once confirmed, I'll:\n"
                "â€¢ Set up your Discord roles\n"
                "â€¢ Send you a website invite for pullallthething.com\n"
                "â€¢ Pre-load your characters in our roster system\n\n"
                "You'll hear from me shortly! In the meantime, "
                "feel free to chat in the Discord. ðŸŽ®"
            ),
            color=PATT_GOLD,
        )
        await dm_channel.send(embed=embed)
        
        # Mark DM as complete and set verification deadline
        now = datetime.now(timezone.utc)
        deadline = now + timedelta(hours=DEADLINE_HOURS)
        
        async with self.db_pool.acquire() as conn:
            await conn.execute(
                """UPDATE guild_identity.onboarding_sessions SET
                    state = 'pending_verification',
                    dm_completed_at = $2,
                    deadline_at = $3,
                    updated_at = NOW()
                   WHERE id = $1""",
                self.session_id, now, deadline
            )
        
        # Attempt immediate verification
        await self._attempt_verification()
    
    async def _handle_not_in_guild(self, dm_channel: discord.DMChannel):
        """Handle case where they haven't joined the guild in-game yet."""
        embed = discord.Embed(
            title="No worries! ðŸ‘‹",
            description=(
                "Whenever you join the guild in WoW, just come back and "
                "reply to this conversation with your character name, "
                "or type **/pattsync** in any channel.\n\n"
                "In the meantime, feel free to hang out in the Discord! "
                "If you need a guild invite, ask any officer â€” "
                "they'll get you sorted. ðŸŽ®\n\n"
                "*I'll check back in with you in about 24 hours!*"
            ),
            color=PATT_GOLD,
        )
        await dm_channel.send(embed=embed)
        
        now = datetime.now(timezone.utc)
        deadline = now + timedelta(hours=DEADLINE_HOURS)
        
        async with self.db_pool.acquire() as conn:
            await conn.execute(
                """UPDATE guild_identity.onboarding_sessions SET
                    state = 'pending_verification',
                    dm_completed_at = $2,
                    deadline_at = $3,
                    updated_at = NOW()
                   WHERE id = $1""",
                self.session_id, now, deadline
            )
    
    async def _try_find_character(self, name: str) -> Optional[dict]:
        """Try to find a character in the roster by name (case-insensitive)."""
        async with self.db_pool.acquire() as conn:
            return await conn.fetchrow(
                """SELECT character_name, realm_slug, realm_name, character_class,
                          guild_rank_name
                   FROM guild_identity.wow_characters
                   WHERE LOWER(character_name) = $1 AND removed_at IS NULL""",
                name.lower()
            )
    
    async def _attempt_verification(self):
        """
        Try to verify the self-reported data against the guild roster.
        
        If the main character is found in the roster, create identity links
        and trigger auto-provisioning.
        
        Called immediately after DM completion and also by the scheduler
        after each Blizzard sync.
        """
        async with self.db_pool.acquire() as conn:
            session = await conn.fetchrow(
                "SELECT * FROM guild_identity.onboarding_sessions WHERE id = $1",
                self.session_id
            )
            
            if not session or session['state'] != 'pending_verification':
                return
            
            main_name = session['reported_main_name']
            if not main_name:
                return
            
            # Find the character
            char = await conn.fetchrow(
                """SELECT id, character_name, realm_slug, person_id
                   FROM guild_identity.wow_characters
                   WHERE LOWER(character_name) = $1 AND removed_at IS NULL""",
                main_name.lower()
            )
            
            if not char:
                # Not found yet â€” will retry on next sync
                await conn.execute(
                    """UPDATE guild_identity.onboarding_sessions SET
                        verification_attempts = verification_attempts + 1,
                        last_verification_at = NOW(),
                        updated_at = NOW()
                       WHERE id = $1""",
                    self.session_id
                )
                return
            
            # Found! Create or use existing person
            person_id = char['person_id']
            if not person_id:
                person_id = await conn.fetchval(
                    """INSERT INTO guild_identity.persons (display_name)
                       VALUES ($1) RETURNING id""",
                    main_name
                )
            
            # Link character to person
            await conn.execute(
                """UPDATE guild_identity.wow_characters SET person_id = $1 WHERE id = $2""",
                person_id, char['id']
            )
            await conn.execute(
                """INSERT INTO guild_identity.identity_links
                   (person_id, wow_character_id, link_source, confidence, is_confirmed)
                   VALUES ($1, $2, 'self_reported', 'high', TRUE)
                   ON CONFLICT (wow_character_id) DO NOTHING""",
                person_id, char['id']
            )
            
            # Link Discord member to person
            dm_row = await conn.fetchrow(
                "SELECT id FROM guild_identity.discord_members WHERE discord_id = $1",
                session['discord_id']
            )
            if dm_row:
                await conn.execute(
                    """UPDATE guild_identity.discord_members SET person_id = $1 WHERE id = $2""",
                    person_id, dm_row['id']
                )
                await conn.execute(
                    """INSERT INTO guild_identity.identity_links
                       (person_id, discord_member_id, link_source, confidence, is_confirmed)
                       VALUES ($1, $2, 'self_reported', 'high', TRUE)
                       ON CONFLICT (discord_member_id) DO NOTHING""",
                    person_id, dm_row['id']
                )
            
            # Also try to link reported alts
            alt_names = session['reported_alt_names'] or []
            for alt_name in alt_names:
                alt_char = await conn.fetchrow(
                    """SELECT id FROM guild_identity.wow_characters
                       WHERE LOWER(character_name) = $1 AND removed_at IS NULL AND person_id IS NULL""",
                    alt_name.lower()
                )
                if alt_char:
                    await conn.execute(
                        "UPDATE guild_identity.wow_characters SET person_id = $1 WHERE id = $2",
                        person_id, alt_char['id']
                    )
                    await conn.execute(
                        """INSERT INTO guild_identity.identity_links
                           (person_id, wow_character_id, link_source, confidence, is_confirmed)
                           VALUES ($1, $2, 'self_reported', 'medium', FALSE)
                           ON CONFLICT (wow_character_id) DO NOTHING""",
                        person_id, alt_char['id']
                    )
            
            # Mark as verified
            await conn.execute(
                """UPDATE guild_identity.onboarding_sessions SET
                    state = 'verified',
                    verified_at = NOW(),
                    verified_person_id = $2,
                    updated_at = NOW()
                   WHERE id = $1""",
                self.session_id, person_id
            )
        
        # Trigger auto-provisioning
        await self._auto_provision(person_id)
    
    async def _auto_provision(self, person_id: int):
        """
        Automatically provision a verified member across all systems.
        
        1. Assign Discord guild role (Initiate by default for new members)
        2. Generate website invite code and DM it to them
        3. Create roster entries for all their characters
        """
        from .provisioner import AutoProvisioner
        
        provisioner = AutoProvisioner(self.bot, self.db_pool)
        
        async with self.db_pool.acquire() as conn:
            session = await conn.fetchrow(
                "SELECT * FROM guild_identity.onboarding_sessions WHERE id = $1",
                self.session_id
            )
        
        member = self.member
        
        # Step 1: Assign Discord role
        role_assigned = await provisioner.assign_discord_role(member, person_id)
        
        # Step 2: Generate and send website invite
        invite_code = await provisioner.create_and_send_website_invite(
            member, person_id, self.session_id
        )
        
        # Step 3: Create roster entries
        roster_created = await provisioner.create_roster_entries(person_id)
        
        # Update session
        async with self.db_pool.acquire() as conn:
            await conn.execute(
                """UPDATE guild_identity.onboarding_sessions SET
                    state = 'provisioned',
                    website_invite_sent = $2,
                    website_invite_code = $3,
                    roster_entries_created = $4,
                    discord_role_assigned = $5,
                    completed_at = NOW(),
                    updated_at = NOW()
                   WHERE id = $1""",
                self.session_id,
                invite_code is not None,
                invite_code,
                roster_created,
                role_assigned,
            )
        
        # Send confirmation DM
        await self._send_provisioned_message(member, invite_code)
    
    async def _send_provisioned_message(
        self, member: discord.Member, invite_code: Optional[str]
    ):
        """Send the 'you're all set' DM with website invite."""
        embed = discord.Embed(
            title="You're officially set up! ðŸŽ‰",
            description="Everything is ready for you:",
            color=0x4ADE80,  # Green
        )
        
        embed.add_field(
            name="âœ… Discord Role",
            value="Your guild role has been assigned!",
            inline=False,
        )
        
        if invite_code:
            embed.add_field(
                name="ðŸŒ Guild Website",
                value=(
                    f"**Your invite code:** `{invite_code}`\n"
                    f"**Sign up here:** https://pullallthething.com/register\n"
                    f"Enter the invite code when prompted. This code is just for you!"
                ),
                inline=False,
            )
        
        embed.add_field(
            name="ðŸ“‹ Roster",
            value=(
                "Your characters have been pre-loaded in our roster system!\n"
                "When you log in to the website, you'll see them listed. "
                "You can mark your main and add any characters I might have missed."
            ),
            inline=False,
        )
        
        embed.add_field(
            name="ðŸ“… Raid Schedule",
            value="Fridays & Saturdays at 6 PM PST / 9 PM EST",
            inline=False,
        )
        
        embed.set_footer(text="Welcome to Pull All The Things! ðŸ”¥ FOR THE HORDE!")
        
        try:
            dm_channel = await member.create_dm()
            await dm_channel.send(embed=embed)
        except discord.Forbidden:
            logger.warning("Cannot DM provisioning details to %s", member.name)
    
    # --- Helper methods ---
    
    async def _wait_for_response(
        self, dm_channel: discord.DMChannel
    ) -> Optional[discord.Message]:
        """Wait for a DM response with timeout."""
        def check(m):
            return m.author == self.member and m.channel == dm_channel
        
        try:
            return await self.bot.wait_for('message', check=check, timeout=RESPONSE_TIMEOUT)
        except asyncio.TimeoutError:
            return None
    
    async def _update_state(self, state: str, notes: str = None):
        """Update the onboarding session state."""
        async with self.db_pool.acquire() as conn:
            if state == 'asked_in_guild':
                await conn.execute(
                    """UPDATE guild_identity.onboarding_sessions SET
                        state = $2, dm_sent_at = NOW(), updated_at = NOW()
                       WHERE id = $1""",
                    self.session_id, state
                )
            else:
                await conn.execute(
                    """UPDATE guild_identity.onboarding_sessions SET
                        state = $2, updated_at = NOW()
                       WHERE id = $1""",
                    self.session_id, state
                )
    
    async def _update_field(self, field: str, value):
        """Update a specific field on the onboarding session."""
        async with self.db_pool.acquire() as conn:
            await conn.execute(
                f"""UPDATE guild_identity.onboarding_sessions SET
                    {field} = $2, updated_at = NOW()
                   WHERE id = $1""",
                self.session_id, value
            )
    
    async def _get_field(self, field: str):
        """Get a specific field from the onboarding session."""
        async with self.db_pool.acquire() as conn:
            return await conn.fetchval(
                f"SELECT {field} FROM guild_identity.onboarding_sessions WHERE id = $1",
                self.session_id
            )
```

## Task 2: Auto-Provisioner

Handles the three provisioning steps: Discord role, website invite, roster entries.

```python
# sv_common/guild_sync/onboarding/provisioner.py

"""
Auto-provisioner for verified guild members.

Once a new member's identity is verified (WoW character matched to Discord account),
this module handles:
1. Discord role assignment (based on in-game rank, defaulting to Initiate)
2. Website invite code generation + DM delivery
3. Roster entry creation (all characters, sensible defaults)

Design principles:
- All characters are listed, NONE with auto-join or alerting enabled
- No character is marked as "main" â€” the member does that themselves on first login
- Website invite codes are single-use and tied to the onboarding session
- Everything is idempotent (safe to retry)
"""

import logging
import secrets
import string
from datetime import datetime, timezone, timedelta
from typing import Optional

import asyncpg
import discord

logger = logging.getLogger(__name__)

# In-game rank â†’ Discord role mapping (from Phase 2.5)
RANK_TO_DISCORD_ROLE = {
    "Guild Leader": "GM",
    "Officer": "Officer",
    "Veteran": "Veteran",
    "Member": "Member",
    "Initiate": "Initiate",
}

# Default role for new members (until we know their in-game rank)
DEFAULT_ROLE = "Initiate"


class AutoProvisioner:
    """Handles automatic provisioning of verified guild members."""
    
    def __init__(self, bot: discord.Client, db_pool: asyncpg.Pool):
        self.bot = bot
        self.db_pool = db_pool
    
    async def assign_discord_role(
        self, member: discord.Member, person_id: int
    ) -> bool:
        """
        Assign the appropriate guild Discord role based on in-game rank.
        
        Looks up the person's highest in-game rank and maps it to a Discord role.
        Falls back to Initiate if no rank info is available yet.
        
        Returns True if role was assigned successfully.
        """
        try:
            # Determine the appropriate role
            async with self.db_pool.acquire() as conn:
                # Get highest in-game rank for this person
                rank_row = await conn.fetchrow(
                    """SELECT guild_rank, guild_rank_name
                       FROM guild_identity.wow_characters
                       WHERE person_id = $1 AND removed_at IS NULL
                       ORDER BY guild_rank ASC
                       LIMIT 1""",
                    person_id
                )
            
            if rank_row and rank_row['guild_rank_name']:
                target_role_name = RANK_TO_DISCORD_ROLE.get(
                    rank_row['guild_rank_name'], DEFAULT_ROLE
                )
            else:
                target_role_name = DEFAULT_ROLE
            
            # Find the role in the guild
            guild = member.guild
            role = discord.utils.get(guild.roles, name=target_role_name)
            
            if not role:
                logger.error("Discord role '%s' not found in guild", target_role_name)
                return False
            
            # Check if they already have it
            if role in member.roles:
                logger.info("%s already has role %s", member.name, target_role_name)
                return True
            
            await member.add_roles(role, reason=f"Auto-provisioned via onboarding (rank: {rank_row['guild_rank_name'] if rank_row else 'unknown'})")
            
            logger.info("Assigned role %s to %s", target_role_name, member.name)
            return True
            
        except discord.Forbidden:
            logger.error("Bot lacks permission to assign roles")
            return False
        except Exception as e:
            logger.error("Failed to assign role to %s: %s", member.name, e)
            return False
    
    async def create_and_send_website_invite(
        self,
        member: discord.Member,
        person_id: int,
        onboarding_session_id: int,
    ) -> Optional[str]:
        """
        Generate a single-use website invite code and record it.
        
        The invite code is:
        - 8 characters, alphanumeric, easy to type
        - Single-use (consumed on registration)
        - Expires in 7 days
        - Tied to the onboarding session and person
        
        Returns the invite code string, or None if creation failed.
        """
        try:
            # Generate a friendly invite code (avoid ambiguous chars like 0/O, 1/l)
            alphabet = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'
            code = ''.join(secrets.choice(alphabet) for _ in range(8))
            
            expires_at = datetime.now(timezone.utc) + timedelta(days=7)
            
            async with self.db_pool.acquire() as conn:
                # Insert into whatever invite table the Phase 2 website uses
                # Adjust this query to match your actual schema
                await conn.execute(
                    """INSERT INTO website_auth.invite_codes
                       (code, person_id, expires_at, max_uses, current_uses,
                        generated_by, onboarding_session_id)
                       VALUES ($1, $2, $3, 1, 0, 'auto_onboarding', $4)""",
                    code, person_id, expires_at, onboarding_session_id
                )
            
            logger.info("Generated website invite %s for person %d", code, person_id)
            return code
            
        except Exception as e:
            logger.error("Failed to create website invite: %s", e)
            return None
    
    async def create_roster_entries(self, person_id: int) -> bool:
        """
        Create roster entries for all of a person's characters.
        
        Rules:
        - ALL characters belonging to this person are listed
        - NO character is marked as "main" (member chooses on first login)
        - NO character has auto-signup for raids enabled
        - NO character has reminder/alerting enabled
        - All characters have default availability (none selected)
        
        This creates entries in whatever roster table the Phase 2 system uses.
        """
        try:
            async with self.db_pool.acquire() as conn:
                # Get all characters for this person
                characters = await conn.fetch(
                    """SELECT id, character_name, realm_slug, realm_name,
                              character_class, active_spec, role_category, level
                       FROM guild_identity.wow_characters
                       WHERE person_id = $1 AND removed_at IS NULL""",
                    person_id
                )
                
                if not characters:
                    logger.warning("No characters found for person %d", person_id)
                    return False
                
                # Get the person's Discord info for the roster
                discord_info = await conn.fetchrow(
                    """SELECT username, display_name, discord_id
                       FROM guild_identity.discord_members
                       WHERE person_id = $1 AND is_present = TRUE""",
                    person_id
                )
                
                discord_name = ""
                if discord_info:
                    discord_name = discord_info['display_name'] or discord_info['username']
                
                for char in characters:
                    # Check if roster entry already exists
                    existing = await conn.fetchrow(
                        """SELECT id FROM roster.characters
                           WHERE LOWER(character_name) = $1 AND LOWER(realm_slug) = $2""",
                        char['character_name'].lower(), char['realm_slug'].lower()
                    )
                    
                    if existing:
                        logger.debug(
                            "Roster entry already exists for %s", char['character_name']
                        )
                        continue
                    
                    # Create roster entry with conservative defaults
                    await conn.execute(
                        """INSERT INTO roster.characters
                           (person_id, character_name, realm_slug, realm_name,
                            character_class, active_spec, role_category, level,
                            discord_name, is_main, auto_signup, receive_reminders,
                            created_by)
                           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9,
                                   FALSE, FALSE, FALSE, 'auto_onboarding')""",
                        person_id,
                        char['character_name'],
                        char['realm_slug'],
                        char['realm_name'] or '',
                        char['character_class'],
                        char['active_spec'] or '',
                        char['role_category'] or '',
                        char['level'] or 0,
                        discord_name,
                    )
                    
                    logger.info(
                        "Created roster entry for %s (%s %s)",
                        char['character_name'], char['character_class'],
                        char['active_spec'] or ''
                    )
                
                logger.info(
                    "Created %d roster entries for person %d",
                    len(characters), person_id
                )
                return True
                
        except Exception as e:
            logger.error("Failed to create roster entries: %s", e)
            return False
```

## Task 3: Deadline Checker & Escalation

Scheduled job that checks for unverified members past their 24-hour deadline.

```python
# sv_common/guild_sync/onboarding/deadline_checker.py

"""
Deadline checker for onboarding sessions.

Runs periodically (every 30 minutes) to:
1. Retry verification for pending sessions (roster data may have arrived)
2. Escalate timed-out sessions to #audit-channel
3. Send follow-up DMs to members who went silent during onboarding

Integrates with the Phase 2.5 scheduler.
"""

import logging
from datetime import datetime, timezone

import asyncpg
import discord

logger = logging.getLogger(__name__)


async def check_onboarding_deadlines(
    db_pool: asyncpg.Pool,
    bot: discord.Client,
    audit_channel: discord.TextChannel,
):
    """
    Check all pending onboarding sessions for deadlines and retry verification.
    
    Called by the scheduler every 30 minutes.
    """
    now = datetime.now(timezone.utc)
    
    async with db_pool.acquire() as conn:
        # Get all pending verification sessions
        pending = await conn.fetch(
            """SELECT os.*, dm.username, dm.display_name
               FROM guild_identity.onboarding_sessions os
               JOIN guild_identity.discord_members dm ON dm.discord_id = os.discord_id
               WHERE os.state = 'pending_verification'"""
        )
    
    for session in pending:
        # Try verification again (roster data might have synced since last attempt)
        from .conversation import OnboardingConversation
        conv = OnboardingConversation.__new__(OnboardingConversation)
        conv.db_pool = db_pool
        conv.bot = bot
        conv.session_id = session['id']
        
        # Get the member object
        for guild in bot.guilds:
            member = guild.get_member(int(session['discord_id']))
            if member:
                conv.member = member
                break
        
        if not hasattr(conv, 'member') or not conv.member:
            logger.warning("Cannot find Discord member %s for onboarding", session['discord_id'])
            continue
        
        await conv._attempt_verification()
        
        # Re-check state (verification might have succeeded)
        async with db_pool.acquire() as conn:
            current_state = await conn.fetchval(
                "SELECT state FROM guild_identity.onboarding_sessions WHERE id = $1",
                session['id']
            )
        
        if current_state == 'provisioned':
            continue  # Verification succeeded, member was provisioned
        
        # Check if past deadline
        if session['deadline_at'] and now > session['deadline_at']:
            if not session['escalated_at']:
                await _escalate_to_audit(db_pool, audit_channel, session)


async def _escalate_to_audit(
    db_pool: asyncpg.Pool,
    channel: discord.TextChannel,
    session: dict,
):
    """Send an escalation message to #audit-channel for an unverified member."""
    display = session['display_name'] or session['username']
    
    embed = discord.Embed(
        title="â° Unverified New Member â€” Action Needed",
        description=(
            f"**{display}** joined Discord more than 24 hours ago "
            f"and could not be automatically verified."
        ),
        color=0xFFA500,  # Orange
    )
    
    if session['reported_main_name']:
        embed.add_field(
            name="Self-Reported Main",
            value=session['reported_main_name'],
            inline=True,
        )
    
    if session['reported_alt_names']:
        embed.add_field(
            name="Self-Reported Alts",
            value=", ".join(session['reported_alt_names']),
            inline=True,
        )
    
    if session['is_in_guild'] is not None:
        embed.add_field(
            name="Says In Guild?",
            value="Yes" if session['is_in_guild'] else "No",
            inline=True,
        )
    
    embed.add_field(
        name="Verification Attempts",
        value=str(session['verification_attempts']),
        inline=True,
    )
    
    embed.add_field(
        name="Possible Actions",
        value=(
            "â€¢ Check if they actually joined the guild in-game\n"
            "â€¢ Use `/onboard-resolve` to manually link them\n"
            "â€¢ Use `/onboard-dismiss` if they're just a Discord visitor"
        ),
        inline=False,
    )
    
    embed.set_footer(text=f"Discord ID: {session['discord_id']}")
    
    await channel.send(embed=embed)
    
    # Mark as escalated and create audit issue
    async with db_pool.acquire() as conn:
        await conn.execute(
            """UPDATE guild_identity.onboarding_sessions SET
                escalated_at = NOW(), updated_at = NOW()
               WHERE id = $1""",
            session['id']
        )
        
        import hashlib
        issue_hash = hashlib.sha256(
            f"unverified_new_member:{session['discord_id']}".encode()
        ).hexdigest()
        
        await conn.execute(
            """INSERT INTO guild_identity.audit_issues
               (issue_type, severity, discord_member_id, summary, details, issue_hash)
               VALUES ('unverified_new_member', 'warning', $1, $2, $3, $4)
               ON CONFLICT (issue_hash, resolved_at) DO NOTHING""",
            session['discord_member_id'] if 'discord_member_id' in session.keys() else None,
            f"Unverified new member: {display} (reported main: {session['reported_main_name'] or 'unknown'})",
            {
                "discord_id": session['discord_id'],
                "reported_main": session['reported_main_name'],
                "reported_alts": session['reported_alt_names'],
                "is_in_guild": session['is_in_guild'],
            },
            issue_hash,
        )
    
    logger.info("Escalated unverified member %s to #audit-channel", display)
```

## Task 4: First-Login Experience (Website)

When a provisioned member logs into the website for the first time, they see their
pre-loaded characters and can configure them.

```python
# sv_common/guild_sync/onboarding/first_login.py

"""
First-login experience for the PATT website.

When a member logs in for the first time after auto-provisioning:
1. Show a welcome screen with their pre-loaded characters
2. Let them mark which character is their "main"
3. Let them add any characters that weren't found automatically
4. Let them set availability preferences

This is a lightweight API endpoint + frontend flow, not a separate system.
"""

import logging
from typing import Optional

import asyncpg
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel

logger = logging.getLogger(__name__)

first_login_router = APIRouter(prefix="/api/onboarding", tags=["Onboarding"])


class FirstLoginResponse(BaseModel):
    """Response for the first-login character review screen."""
    is_first_login: bool
    person_id: int
    display_name: str
    characters: list[dict]  # Pre-loaded characters
    needs_main_selection: bool
    welcome_message: str


class SetMainRequest(BaseModel):
    character_id: int


class AddCharacterRequest(BaseModel):
    character_name: str
    realm: str = ""
    character_class: str = ""
    spec: str = ""
    role_category: str = ""  # Tank, Healer, Melee, Ranged


@first_login_router.get("/first-login")
async def get_first_login_data(
    # person_id from auth session
    # db_pool = Depends(get_db_pool),
) -> FirstLoginResponse:
    """
    Get the first-login data for the current user.
    
    Returns their pre-loaded characters and whether they need to
    select a main character.
    """
    person_id = 1  # From auth session
    
    # Check if they have any character marked as main
    # If not, this is effectively their "first login" experience
    
    # Query all their characters from the roster
    characters = []  # From roster.characters WHERE person_id = X
    
    has_main = any(c.get('is_main') for c in characters)
    
    return FirstLoginResponse(
        is_first_login=not has_main,
        person_id=person_id,
        display_name="",  # From persons table
        characters=characters,
        needs_main_selection=not has_main,
        welcome_message=(
            "Welcome to Pull All The Things! ðŸŽ®\n\n"
            "We've pre-loaded your characters from the guild roster. "
            "Please select your **main character** and verify everything looks right.\n\n"
            "You can also add any characters we might have missed."
        ) if not has_main else ""
    )


@first_login_router.post("/set-main")
async def set_main_character(
    req: SetMainRequest,
    # person_id from auth session
    # db_pool = Depends(get_db_pool),
):
    """Mark a character as the user's main."""
    person_id = 1  # From auth session
    
    # Verify the character belongs to this person
    # Unset any existing main for this person
    # Set the new main
    
    return {"status": "main_set"}


@first_login_router.post("/add-character")
async def add_character(
    req: AddCharacterRequest,
    # person_id from auth session
    # db_pool = Depends(get_db_pool),
):
    """
    Add a character that wasn't found automatically.
    
    This handles the case where:
    - Character is on a different realm and wasn't in the guild roster
    - Character just joined and hasn't been synced yet
    - Character is a bank alt or non-guild character they want tracked
    
    Creates both a wow_characters entry (if needed) and a roster entry.
    """
    person_id = 1  # From auth session
    
    # Try to find the character in wow_characters
    # If found, link to person and create roster entry
    # If not found, create both entries as "user_reported"
    
    return {"status": "character_added"}
```

## Task 5: Scheduler Integration

Add onboarding checks to the Phase 2.5 scheduler.

```python
# Add to sv_common/guild_sync/scheduler.py

# In GuildSyncScheduler.__init__, add:
#     from .onboarding.deadline_checker import check_onboarding_deadlines

# In GuildSyncScheduler.start(), add this job:
#     self.scheduler.add_job(
#         self.check_onboarding,
#         IntervalTrigger(minutes=30),
#         id="onboarding_check",
#         name="Onboarding Deadline & Verification Check",
#         misfire_grace_time=600,
#     )

# New method:
#     async def check_onboarding(self):
#         channel = self._get_audit_channel()
#         if channel:
#             await check_onboarding_deadlines(self.db_pool, self.discord_bot, channel)

# In run_blizzard_sync(), after matching engine runs, add:
#     # Re-check pending onboarding sessions (new roster data might verify them)
#     await self.check_onboarding()
```

## Task 6: Bot Event Handler Integration

Wire the onboarding conversation into the existing bot's on_member_join.

```python
# Add to the Discord bot's event registration (Phase 2 bot setup):

# In the bot's on_member_join handler:
#
# @bot.event
# async def on_member_join(member):
#     if member.bot:
#         return
#     
#     # Phase 2.5: Record the new member
#     await discord_sync.on_member_join(db_pool, member)
#     
#     # Phase 2.6: Start onboarding conversation
#     from sv_common.guild_sync.onboarding.conversation import OnboardingConversation
#     conv = OnboardingConversation(bot, member, db_pool)
#     asyncio.create_task(conv.start())
```

## Task 7: Officer Slash Commands

```python
# sv_common/guild_sync/onboarding/commands.py

"""
Officer slash commands for managing onboarding.

/onboard-status              â€” Show all pending onboarding sessions
/onboard-resolve <user>      â€” Manually resolve a stuck onboarding
/onboard-dismiss <user>      â€” Mark a visitor (not a guild member)
/onboard-retry <user>        â€” Re-attempt verification for a member
"""

# These register as discord.app_commands on the existing bot.
# Implementation follows the same pattern as other Phase 2 slash commands.
# Each command checks for Officer or GM role before executing.
```

## File Organization

```
sv_common/
  guild_sync/
    onboarding/
      __init__.py
      conversation.py        # DM onboarding flow + state machine
      provisioner.py          # Auto-provisioning (roles, invite, roster)
      deadline_checker.py     # 24h escalation + retry logic
      first_login.py          # Website first-login API endpoints
      commands.py             # Officer slash commands
```

## Testing Requirements for Phase 2.6

1. **Conversation flow tests:**
   - Test welcome DM sends correctly
   - Test "yes" path (in guild) through to main + alts
   - Test "no" path (not in guild yet)
   - Test ambiguous answers
   - Test timeout handling (member goes silent)
   - Test DMs-closed handling

2. **Verification tests:**
   - Test immediate verification when character exists in roster
   - Test deferred verification (character not found yet, found on next sync)
   - Test alt linking from self-reported names
   - Test fuzzy name matching on reported characters

3. **Provisioner tests:**
   - Test Discord role assignment (correct rank mapping)
   - Test role assignment defaults to Initiate when rank unknown
   - Test invite code generation (format, uniqueness)
   - Test roster entry creation (all chars listed, none marked main, no auto-signup)
   - Test idempotency (running provisioner twice doesn't duplicate)

4. **Deadline checker tests:**
   - Test escalation fires after 24 hours
   - Test re-verification on each check
   - Test no double-escalation
   - Test audit issue creation on escalation

5. **First-login tests:**
   - Test returns characters correctly
   - Test needs_main_selection flag
   - Test set-main updates correctly
   - Test add-character creates entries
   - Test user can only modify their own characters

6. **Integration tests:**
   - Full flow: join â†’ DM â†’ verify â†’ provision â†’ first login â†’ set main
   - Full flow: join â†’ DM â†’ not verified â†’ 24h â†’ escalate â†’ officer resolves
